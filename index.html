<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-Label Classifier - Testing</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas, img { max-width: 100px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Testing LEGO Classifier</h1>
    <input type="file" id="pdfUpload" accept="application/pdf">
    <div id="predictions"></div>

    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script>
    const categories = [
        'bagset', 'dontreadrepeat', 'finish', 'index', 'pageno',
        'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'
    ];

    async function loadModel() {
        await tf.setBackend('webgl').catch(async () => {
            await tf.setBackend('wasm').catch(() => tf.setBackend('cpu'));
        });
        await tf.ready();
        return await tf.loadLayersModel('model/modelfiles/lego-classifier.json');
    }

    async function processPageImages(model, pdf, pageNum) {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2.0 });
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await page.render({ canvasContext: context, viewport }).promise;

        const img = new Image();
        img.src = canvas.toDataURL();
        await new Promise(resolve => img.onload = resolve);

        await predictImage(model, img, pageNum);
    }

    async function predictImage(model, imgElement, pageNum) {
        const tensor = tf.browser.fromPixels(imgElement)
            .resizeNearestNeighbor([64, 64])
            .toFloat()
            .div(255.0)
            .expandDims();

        const prediction = model.predict(tensor);
        const values = await prediction.data();

        const results = Array.from(values)
            .map((v, i) => ({ label: categories[i], confidence: v }))
            .filter(r => r.confidence > 0.5);

        const output = document.getElementById('predictions');
        const resultHTML = `<h3>Page ${pageNum}</h3>` +
            (results.length ?
                results.map(r => `<div>${r.label}: ${(r.confidence * 100).toFixed(1)}%</div>`).join('') :
                '<div>No confident predictions</div>');
        output.innerHTML += resultHTML;
    }

    document.getElementById('pdfUpload').addEventListener('change', async event => {
        const file = event.target.files[0];
        if (!file) return;

        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const model = await loadModel();

        for (let i = 1; i <= pdf.numPages; i++) {
            await processPageImages(model, pdf, i);
        }
    });
    </script>
</body>
</html>
