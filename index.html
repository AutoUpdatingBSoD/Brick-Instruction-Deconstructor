<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<input type="file" id="imageUpload" multiple>
<div id="testlog"></div>
<script>
const testlog = document.getElementById("testlog");

const categories = ['bagset', 'dontreadrepeat', 'finish', 'index', 'pageno', 'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'];
const indices = [5, 2, 2, 4, 4, 26, 18, 4, 2, 6];
const baseDir = 'model/dataset/';

// Setup backend
await tf.setBackend('webgl');
console.log("Backend:", tf.getBackend());

// Model
const model = tf.sequential();
model.add(tf.layers.conv2d({ inputShape: [96, 96, 3], filters: 16, kernelSize: 3, activation: 'relu' }));
model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));
model.add(tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: 'relu' }));
model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));
model.add(tf.layers.flatten());
model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
model.add(tf.layers.dense({ units: categories.length, activation: 'sigmoid' }));
model.compile({ optimizer: tf.train.adam(), loss: 'binaryCrossentropy', metrics: ['accuracy'] });

async function loadImage(url) {
    return new Promise(resolve => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        img.onload = () => resolve(img);
    });
}

function processImage(img) {
    return tf.tidy(() => {
        return tf.browser.fromPixels(img)
            .resizeNearestNeighbor([96, 96])
            .toFloat()
            .div(255)
            .expandDims();
    });
}

function getLabelVector(index) {
    const vec = new Array(categories.length).fill(0);
    switch (index) {
        case 0: vec[0] = 1; break;
        case 1: vec[1] = 1; break;
        case 2: vec[2] = 1; vec[4] = 1; break;
        case 3: vec[3] = 1; vec[4] = 1; vec[5] = 1; vec[7] = 1; break;
        case 4: vec[4] = 1; break;
        case 5: vec[5] = 1; vec[7] = 1; break;
        case 6: vec[6] = 1; vec[7] = 1; break;
        case 7: vec[7] = 1; break;
        case 8: vec[4] = 1; vec[8] = 1; break;
        case 9: vec[2] = 1; vec[9] = 1; break;
    }
    return tf.tensor2d([vec]);
}

async function* dataGenerator() {
    for (let j = 0; j < categories.length; j++) {
        for (let i = 1; i <= indices[j]; i++) {
            const url = `${baseDir}${categories[j]}/${categories[j]} ${i}.png`;
            try {
                const response = await fetch(url, { method: 'HEAD' });
                if (!response.ok) break;
                const img = await loadImage(url);
                const xs = processImage(img);
                const ys = getLabelVector(j);
                yield { xs, ys };
            } catch (e) {
                console.warn("Skipped:", url);
                break;
            }
        }
    }
}

async function trainModel() {
    let i = 0;
    for await (const { xs, ys } of dataGenerator()) {
        await model.fit(xs, ys, {
            batchSize: 1,
            epochs: 1
        });
        xs.dispose();
        ys.dispose();
        if (++i % 10 === 0) console.log(`Trained ${i} samples`);
    }
    console.log("Training complete");
}

async function classifyExtractedImages(pdfUrl) {
    const images = await extractImagesFromPDF(pdfUrl);
    for (const src of images) {
        const img = await loadImage(src);
        const input = processImage(img);
        const prediction = model.predict(input);
        const data = await prediction.data();
        input.dispose();
        prediction.dispose();

        data.forEach((val, i) => {
            if (val > 0.5) {
                testlog.innerHTML += `<br>Detected: ${categories[i]} (${val.toFixed(2)})`;
            }
        });
    }
}

async function extractImagesFromPDF(pdfUrl) {
    const pdf = await pdfjsLib.getDocument(pdfUrl).promise;
    const images = [];
    for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1.0 });
        const canvas = document.createElement("canvas");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext("2d");
        await page.render({ canvasContext: ctx, viewport }).promise;
        images.push(canvas.toDataURL("image/jpeg"));
    }
    return images;
}

$(document).ready(() => {
    $("#imageUpload").on("change", async function(event) {
        const file = event.target.files[0];
        const url = URL.createObjectURL(file);
        await classifyExtractedImages(url);
    });
    trainModel();
});
</script>
