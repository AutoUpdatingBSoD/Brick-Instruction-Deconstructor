<!DOCTYPE html>
<html>
<head>
  <title>LEGO Multi-Label Classifier - Testing</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas, img { max-width: 200px; margin: 5px; display: block; }
    #output { margin-top: 20px; }
  </style>
</head>
<body>
<h1>Testing LEGO Classifier</h1>
<input type="file" id="pdfInput" accept="application/pdf">
<div id="output"></div>

<script>
const categories = [
    'bagset', 'dontreadrepeat', 'finish', 'index', 'pageno',
    'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'
];

const THRESHOLD = 0.5;

async function setupBackend() {
    try {
        await tf.setBackend('webgl');
    } catch {
        try {
            await tf.setBackend('wasm');
        } catch {
            await tf.setBackend('cpu');
        }
    }
    await tf.ready();
}

async function loadModel() {
    return await tf.loadLayersModel('model/modelfiles/lego-classifier.json');
}

function predictImage(model, imageTensor) {
    const input = tf.tidy(() => imageTensor.expandDims(0).toFloat().div(255));
    const prediction = model.predict(input);
    const result = prediction.dataSync();
    tf.dispose([input, prediction]);
    return result;
}

async function extractImagesFromPDF(file) {
    const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
    const pdf = await loadingTask.promise;
    const images = [];

    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2 });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext('2d');

        await page.render({ canvasContext: context, viewport }).promise;

        const fullImage = tf.browser.fromPixels(canvas);
        const height = fullImage.shape[0];
        const width = fullImage.shape[1];

        const step = 256; // stride for moving window
        const patchSize = 64;

        for (let y = 0; y <= height - patchSize; y += step) {
            for (let x = 0; x <= width - patchSize; x += step) {
                const patch = tf.tidy(() => fullImage.slice([y, x, 0], [patchSize, patchSize, 3]));
                images.push({ tensor: patch, page: pageNum, x, y });
            }
        }
        tf.dispose(fullImage);
    }

    return images;
}

function displayResults(results) {
    const output = document.getElementById('output');
    output.innerHTML = '';

    results.forEach(({ page, x, y, labels }) => {
        const div = document.createElement('div');
        div.innerText = `Page ${page} | (${x}, ${y}) â†’ ${labels.join(', ')}`;
        output.appendChild(div);
    });
}

async function handlePDF(file) {
    const model = await loadModel();
    const imagePatches = await extractImagesFromPDF(file);
    const results = [];

    for (const { tensor, page, x, y } of imagePatches) {
        const resized = tf.image.resizeBilinear(tensor, [64, 64]);
        const predictions = predictImage(model, resized);
        const labels = [];

        predictions.forEach((p, i) => {
            if (p > THRESHOLD) labels.push(categories[i]);
        });

        if (labels.length) {
            results.push({ page, x, y, labels });
        }

        tf.dispose([tensor, resized]);
    }

    model.dispose();
    displayResults(results);
}

document.getElementById('pdfInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        document.getElementById('output').innerText = 'Processing PDF...';
        setupBackend().then(() => handlePDF(file));
    }
});
</script>
</body>
</html>
