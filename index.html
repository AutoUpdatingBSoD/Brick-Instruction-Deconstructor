<!DOCTYPE html>
<html>
<head>
    <title>LEGO Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas, img { max-width: 100px; margin: 5px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>LEGO Classifier Training</h1>
    <select id="modeSelect">
        <option value="page">Train Page Type Model</option>
        <option value="section">Train Section Type Model</option>
    </select>

    <div id="trainer">
        <input type="file" id="imageUpload" webkitdirectory directory multiple>
        <button id="startTraining">Start Training</button>
        <div id="status"></div>
    </div>

    <script>
    const pageCategories = ['finish', 'index'];
    const sectionCategories = ['part', 'partstep', 'repeat', 'splitdecision', 'subbuild'];

    document.getElementById('startTraining').addEventListener('click', async () => {
        const mode = document.getElementById('modeSelect').value;
        const files = document.getElementById('imageUpload').files;
        if (!files.length) return alert('Please upload images.');

        const labels = [], images = [];
        for (let file of files) {
            const label = file.webkitRelativePath.split('/')[1];
            const categoryList = mode === 'page' ? pageCategories : sectionCategories;
            const index = categoryList.indexOf(label);
            if (index === -1) continue;

            const img = await loadImage(file);
            const tensor = tf.browser.fromPixels(img)
                .resizeNearestNeighbor([64, 64])
                .toFloat()
                .div(255.0)
                .expandDims();
            images.push(tensor);
            labels.push(index);
        }

        const xs = tf.concat(images);
        const ys = tf.oneHot(tf.tensor1d(labels, 'int32'), mode === 'page' ? pageCategories.length : sectionCategories.length);

        const model = tf.sequential();
        model.add(tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: 'relu', inputShape: [64, 64, 3] }));
        model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: (mode === 'page' ? pageCategories.length : sectionCategories.length), activation: 'softmax' }));

        model.compile({ loss: 'categoricalCrossentropy', optimizer: 'adam', metrics: ['accuracy'] });

        document.getElementById('status').innerText = 'Training...';
        await model.fit(xs, ys, {
            epochs: 10,
            batchSize: 32,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    document.getElementById('status').innerText = `Epoch ${epoch + 1}: Accuracy = ${logs.acc.toFixed(2)}`;
                }
            }
        });

        const path = mode === 'page' ? 'model/page_type' : 'model/section_type';
        await model.save(`downloads://${path}`);
        document.getElementById('status').innerText = `Model saved to ${path}`;
    });

    function loadImage(file) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }
    </script>
</body>
</html>
