<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-label Classifier - Testing</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
    <h1>LEGO Classifier - Test PDF</h1>
    <input type="file" id="pdfUpload" accept=".pdf" />
    <div id="results"></div>

    <script>
        const categories = [
            'bagset', 'dontreadrepeat', 'finish', 'index', 'pageno',
            'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'
        ];

        let model;

        async function loadModel() {
            try {
                await tf.setBackend('webgl');
            } catch {
                try {
                    await tf.setBackend('wasm');
                } catch {
                    await tf.setBackend('cpu');
                }
            }
            await tf.ready();
            model = await tf.loadLayersModel('model/modelfiles/model.json');
            console.log('Model loaded.');
        }

        async function pdfToImages(pdfData) {
            const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
            const pages = [];

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.5 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await page.render({ canvasContext: context, viewport }).promise;

                const imageData = canvas.toDataURL('image/png');
                pages.push(imageData);
            }

            return pages;
        }

        async function classifyImage(imgDataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = async () => {
                    const tensor = tf.browser.fromPixels(img)
                        .resizeNearestNeighbor([64, 64])
                        .toFloat()
                        .div(255.0)
                        .expandDims();
                    const prediction = await model.predict(tensor).data();
                    resolve(prediction);
                };
                img.src = imgDataUrl;
            });
        }

        function renderResults(predictions, index) {
            const resultDiv = document.getElementById('results');
            const filtered = predictions
                .map((p, i) => ({ label: categories[i], value: p }))
                .filter(p => p.value > 0.5)
                .sort((a, b) => b.value - a.value);
            const html = `
                <h3>Page ${index + 1}</h3>
                ${filtered.length
                    ? filtered.map(p => `<p>${p.label}: ${p.value.toFixed(2)}</p>`).join('')
                    : '<p>No confident prediction.</p>'
                }
                <hr/>
            `;
            resultDiv.innerHTML += html;
        }

        document.getElementById('pdfUpload').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const arrayBuffer = await file.arrayBuffer();
            const images = await pdfToImages(arrayBuffer);
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>Processing...</p>';

            for (let i = 0; i < images.length; i++) {
                const predictions = await classifyImage(images[i]);
                renderResults(predictions, i);
            }
        });

        loadModel();
    </script>
</body>
</html>
