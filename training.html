<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-Label Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas, img { max-width: 100px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Training LEGO Classifier</h1>
    <div id="status"></div>

    <script>
    const pageCategories = ['finish', 'index'];
    const sectionCategories = [
        'bagset', 'dontreadrepeat', 'pageno', 'part',
        'partstep', 'repeat', 'splitdecision', 'subbuild'
    ];
    const imageDir = 'model/dataset';

    const pageIndices = [2, 4];
    const sectionIndices = [5, 2, 4, 26, 18, 4, 2, 6];

    function getLabelVector(index, isPage) {
        const labelVector = new Array(isPage ? pageCategories.length : sectionCategories.length).fill(0);
        labelVector[index] = 1;
        return labelVector;
    }

    function getSectionMaskForPageType(pageTypeIndex) {
        const mask = new Array(sectionCategories.length).fill(0);
        switch (pageTypeIndex) {
            case 0: // finish
                mask[0] = 1; mask[2] = 1; mask[3] = 1; mask[4] = 1; break;
            case 1: // index
                mask[1] = 1; mask[4] = 1; mask[5] = 1; mask[7] = 1; break;
        }
        return mask;
    }

    async function loadImages(categories, indices, isPage) {
        const images = [];
        const labels = [];

        for (let label = 0; label < categories.length; label++) {
            for (let i = 0; i < indices[label]; i++) {
                const imgPath = `${imageDir}/${categories[label]}/${categories[label]} ${i}.png`;
                const img = new Image();
                img.src = imgPath;
                await new Promise((resolve) => { img.onload = resolve; });

                const tensor = tf.browser.fromPixels(img)
                    .resizeNearestNeighbor([64, 64])
                    .toFloat()
                    .div(255.0);
                images.push(tensor);
                labels.push(getLabelVector(label, isPage));
            }
        }

        return { xs: tf.stack(images), ys: tf.tensor2d(labels) };
    }

    async function trainModel(name, xs, ys, labelSize) {
        const model = tf.sequential();
        model.add(tf.layers.conv2d({ inputShape: [64, 64, 3], filters: 32, kernelSize: 3, activation: 'relu' }));
        model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: labelSize, activation: 'sigmoid' }));

        model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });

        await model.fit(xs, ys, {
            epochs: 15,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    document.getElementById('status').innerText = `${name} - Epoch ${epoch + 1}: loss=${logs.loss.toFixed(4)}, acc=${logs.acc.toFixed(4)}`;
                }
            }
        });

        await model.save(`downloads://${name}-model`);
        document.getElementById('status').innerText += `\n${name} model saved successfully!`;
    }

    (async () => {
        const pageData = await loadImages(pageCategories, pageIndices, true);
        await trainModel('page', pageData.xs, pageData.ys, pageCategories.length);

        const sectionData = await loadImages(sectionCategories, sectionIndices, false);
        await trainModel('section', sectionData.xs, sectionData.ys, sectionCategories.length);
    })();
    </script>
</body>
</html>
