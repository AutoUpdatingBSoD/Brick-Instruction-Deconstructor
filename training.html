<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LEGO Classifier Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
    <div id="trainlog">Training in progress...</div>

    <script>
        const trainlog = document.getElementById("trainlog");
        const categories = ['bagset', 'dontreadrepeat', 'finish', 'index', 'pageno', 'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'];

        async function setupBackend() {
            const backends = ['webgl', 'wasm', 'cpu'];
            for (const backend of backends) {
                try {
                    await tf.setBackend(backend);
                    await tf.ready();
                    console.log(`Using backend: ${tf.getBackend()}`);
                    break;
                } catch (e) {
                    console.warn(`Backend '${backend}' failed to initialize.`);
                }
            }
        }

        async function loadImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = url;
                img.onload = () => resolve(img);
            });
        }

        async function processImage(img) {
            return tf.tidy(() => {
                return tf.browser.fromPixels(img)
                    .resizeNearestNeighbor([64, 64])
                    .toFloat()
                    .div(255);
            });
        }

        async function loadDataset() {
            const dataset = [];
            const indices = [5, 2, 2, 4, 4, 26, 18, 4, 2, 6];
            const baseDir = 'model/dataset/';

            for (let j = 0; j < categories.length; j++) {
                const category = categories[j];
                const jth = indices[j];
                for (let i = 1; i <= jth; i++) {
                    const imageUrl = `${baseDir}${category}/${category} ${i}.png`;
                    try {
                        const response = await fetch(imageUrl, { method: 'HEAD' });
                        if (!response.ok) break;
                        dataset.push({ path: imageUrl, label: j });
                    } catch (error) {
                        break;
                    }
                }
            }

            const imageTensors = [];
            const labels = [];

            for (const item of dataset) {
                const img = await loadImage(item.path);
                const tensor = await processImage(img);
                imageTensors.push(tensor);

                const labelVector = new Array(categories.length).fill(0);
                labelVector[item.label] = 1;
                labels.push(labelVector);
            }

            return {
                xs: tf.stack(imageTensors),
                ys: tf.tensor2d(labels)
            };
        }

        async function trainModel() {
            const input = tf.input({ shape: [64, 64, 3] });
            let x = tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: 'relu' }).apply(input);
            x = tf.layers.maxPooling2d({ poolSize: [2, 2] }).apply(x);
            x = tf.layers.conv2d({ filters: 64, kernelSize: 3, activation: 'relu' }).apply(x);
            x = tf.layers.maxPooling2d({ poolSize: [2, 2] }).apply(x);
            x = tf.layers.flatten().apply(x);
            x = tf.layers.dense({ units: 128, activation: 'relu' }).apply(x);
            const output = tf.layers.dense({ units: categories.length, activation: 'sigmoid' }).apply(x);

            const model = tf.model({ inputs: input, outputs: output });
            model.compile({
                optimizer: tf.train.adam(),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });

            const { xs, ys } = await loadDataset();

            await model.fit(xs, ys, {
                epochs: 20,
                batchSize: 16,
                validationSplit: 0.2,
                callbacks: tf.callbacks.earlyStopping({ patience: 3 })
            });

            await model.save('downloads://lego-classifier');
            xs.dispose();
            ys.dispose();
            trainlog.innerHTML += "<br><br><strong>Training Complete</strong><br>Model downloaded.";
        }

        (async () => {
            await setupBackend();
            await trainModel();
        })();
    </script>
</body>
</html>
