<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-Label Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas, img { max-width: 100px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Training LEGO Classifier</h1>
    <div id="status"></div>

    <script>
    const pageCategories = ['finish', 'index'];
    const sectionCategories = [
        'bagset', 'dontreadrepeat', 'pageno', 'part',
        'partstep', 'repeat', 'splitdecision', 'subbuild'
    ];
    const imageDir = 'model/dataset';

    const pageIndices = [2, 4];
    const sectionIndices = [5, 2, 4, 26, 18, 4, 2, 6];

    function getLabelVector(categoryIndex) {
        const labelVector = new Array(10).fill(0);
        switch (categoryIndex) {
            case 0: labelVector[2] = 1; labelVector[4] = 1; break;
            case 1: labelVector[3] = 1; labelVector[4] = 1; labelVector[5] = 1; labelVector[7] = 1; break;
            case 2: labelVector[0] = 1; break;
            case 3: labelVector[1] = 1; break;
            case 4: labelVector[4] = 1; break;
            case 5: labelVector[5] = 1; labelVector[7] = 1; break;
            case 6: labelVector[6] = 1; labelVector[7] = 1; break;
            case 7: labelVector[7] = 1; break;
            case 8: labelVector[4] = 1; labelVector[8] = 1; break;
            case 9: labelVector[1] = 1; labelVector[9] = 1; break;
        }
        return labelVector;
    }

    async function loadImages(categories, indices, ith) {
        const images = [];
        const labels = [];
        
        for (let label = ith; label < categories.length; label++) {
            for (let i = 0; i < indices[label]; i++) {
                const imgPath = `${imageDir}/${categories[label]}/${categories[label]} ${i}.png`;
                const img = new Image();
                img.src = imgPath;
                await new Promise((resolve) => { img.onload = resolve; });

                const tensor = tf.browser.fromPixels(img)
                    .resizeNearestNeighbor([64, 64])
                    .toFloat()
                    .div(255.0);
                images.push(tensor);
                labels.push(getLabelVector(label));
            }
        }

        return { xs: tf.stack(images), ys: tf.tensor2d(labels) };
    }

    async function trainModel(name, xs, ys) {
        const model = tf.sequential();
        model.add(tf.layers.conv2d({ inputShape: [64, 64, 3], filters: 32, kernelSize: 3, activation: 'relu' }));
        model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 10, activation: 'sigmoid' }));

        model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });

        await model.fit(xs, ys, {
            epochs: 15,
            batchSize: 16,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    document.getElementById('status').innerText = `${name} - Epoch ${epoch + 1}: loss=${logs.loss.toFixed(4)}, acc=${logs.acc.toFixed(4)}`;
                }
            }
        });

        await model.save(`downloads://${name}-model`);
        document.getElementById('status').innerText += `\n${name} model saved successfully!`;
    }

    (async () => {
        const pageData = await loadImages(pageCategories, pageIndices, 0);
        await trainModel('page', pageData.xs, pageData.ys);

        const sectionData = await loadImages(sectionCategories, sectionIndices, 2);
        await trainModel('section', sectionData.xs, sectionData.ys);
    })();
    </script>
</body>
</html>
