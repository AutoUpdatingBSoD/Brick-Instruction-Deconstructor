<!DOCTYPE html>
<html>
<head>
    <title>LEGO Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
<h1>Training LEGO Classifier</h1>
<p id="status">Loading...</p>

<script type="module">
import { images, indices } from './images/indexlist.js';

const categories = [
    'bagset', 'dontreadrepeat', 'finish', 'index', 'pageno',
    'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'
];

const labelMap = [
    [1,0,0,0,0,0,0,0,0,0],  // bagset
    [0,1,0,0,0,0,0,0,0,0],  // dontreadrepeat
    [0,0,1,0,1,0,0,0,0,0],  // finish
    [0,0,0,1,1,1,0,1,0,0],  // index
    [0,0,0,0,1,0,0,0,0,0],  // pageno
    [0,0,0,0,0,1,0,1,0,0],  // part
    [0,0,0,0,0,0,1,1,0,0],  // partstep
    [0,0,0,0,0,0,0,1,0,0],  // repeat
    [0,0,0,0,1,0,0,0,1,0],  // splitdecision
    [0,1,0,0,0,0,0,0,0,1]   // subbuild
];

const width = 64, height = 64;
const channels = 3;
const xsArray = [], ysArray = [];

const loadImage = async (src) => {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = Float32Array.from(imageData.data).filter((_, i) => i % 4 !== 3).map(v => v / 255);
            resolve(data);
        };
        img.src = src;
    });
};

const loadAllImages = async () => {
    for (let i = 0; i < images.length; i++) {
        const imagePath = `images/${images[i]}`;
        const labelIndex = indices[i];
        const labelVector = labelMap[labelIndex];

        const imageData = await loadImage(imagePath);
        xsArray.push(imageData);
        ysArray.push(labelVector);
        document.getElementById('status').textContent = `Loaded ${i+1} / ${images.length}`;
    }
};

const run = async () => {
    await tf.setBackend('webgl').catch(async () => {
        await tf.setBackend('wasm').catch(() => tf.setBackend('cpu'));
    });
    await tf.ready();

    await loadAllImages();

    const xs = tf.tensor4d(xsArray, [xsArray.length, height, width, channels]);
    const ys = tf.tensor2d(ysArray);

    const input = tf.input({ shape: [height, width, channels] });
    let x = tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: 'relu' }).apply(input);
    x = tf.layers.maxPooling2d({ poolSize: [2, 2] }).apply(x);
    x = tf.layers.flatten().apply(x);
    x = tf.layers.dense({ units: 128, activation: 'relu' }).apply(x);
    const output = tf.layers.dense({ units: categories.length, activation: 'sigmoid' }).apply(x);

    const model = tf.model({ inputs: input, outputs: output });
    model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });

    document.getElementById('status').textContent = 'Training...';
    await model.fit(xs, ys, {
        epochs: 20,
        batchSize: 16,
        validationSplit: 0.2,
        callbacks: tf.callbacks.earlyStopping({ patience: 3 })
    });

    await model.save('downloads://lego-classifier');
    document.getElementById('status').textContent = 'Training Complete. Model saved.';
};

run();
</script>
</body>
</html>
