<!-- training.html -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
const categories = ['bagset', 'dontreadrepeat', 'finish', 'index', 'pageno', 'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'];

async function setupTrainingBackend() {
    await tf.setBackend('cpu');
    await tf.ready();
    console.log(`Training backend: ${tf.getBackend()}`);
}
setupTrainingBackend();

async function loadImage(url) {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        img.onload = () => resolve(img);
    });
}

async function processImage(img) {
    return tf.tidy(() => {
        return tf.browser.fromPixels(img)
            .resizeNearestNeighbor([128, 128])
            .toFloat()
            .div(255);
    });
}

const input = tf.input({ shape: [128, 128, 3] });
let x = tf.layers.conv2d({ filters: 32, kernelSize: 3, activation: 'relu' }).apply(input);
x = tf.layers.maxPooling2d({ poolSize: [2, 2] }).apply(x);
x = tf.layers.conv2d({ filters: 64, kernelSize: 3, activation: 'relu' }).apply(x);
x = tf.layers.maxPooling2d({ poolSize: [2, 2] }).apply(x);
x = tf.layers.flatten().apply(x);
x = tf.layers.dense({ units: 128, activation: 'relu' }).apply(x);
const output = tf.layers.dense({ units: categories.length, activation: 'sigmoid' }).apply(x);
const model = tf.model({ inputs: input, outputs: output });
model.compile({ optimizer: tf.train.adam(), loss: 'binaryCrossentropy', metrics: ['accuracy'] });

async function loadDataset() {
    const dataset = [];
    const indices = [5, 2, 2, 4, 4, 26, 18, 4, 2, 6];
    const baseDir = 'model/dataset/';

    for (let j = 0; j < categories.length; j++) {
        const category = categories[j];
        const jth = indices[j];
        for (let i = 1; i <= jth; i++) {
            const imageUrl = `${baseDir}${category}/${category} ${i}.png`;
            try {
                const response = await fetch(imageUrl, { method: 'HEAD' });
                if (!response.ok) break;
                dataset.push({ path: imageUrl, label: j });
            } catch (error) {
                break;
            }
        }
    }

    const imageTensors = [];
    const labels = [];

    for (const item of dataset) {
        const img = await loadImage(item.path);
        const tensor = await processImage(img);
        imageTensors.push(tensor);

        const labelVector = new Array(categories.length).fill(0);
        labelVector[item.label] = 1;
        labels.push(labelVector);
    }

    return {
        xs: tf.stack(imageTensors),
        ys: tf.tensor2d(labels)
    };
}

async function trainModel() {
    const { xs, ys } = await loadDataset();
    await model.fit(xs, ys, {
        epochs: 20,
        batchSize: 16,
        validationSplit: 0.2,
        callbacks: tf.callbacks.earlyStopping({ patience: 3 })
    });
    await model.save('downloads://lego-classifier');
    xs.dispose();
    ys.dispose();
    alert("Training Complete and Model Saved");
}

$(document).ready(() => {
    trainModel();
});
</script>
