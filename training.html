**training.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-Label Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        canvas, img { max-width: 100px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Training LEGO Classifier (Multi-label)</h1>
    <div id="status">Loading images and training...</div>

    <script>
    const categories = [
        'bagset', 'dontreadrepeat', 'finish', 'index', 'pageno',
        'part', 'partstep', 'repeat', 'splitdecision', 'subbuild'
    ];
    const indices = [5, 2, 2, 4, 4, 26, 18, 4, 2, 6];
    const imageDir = 'model/dataset';

    async function loadImagesAndLabels() {
        const images = [];
        const labels = [];

        for (let label = 0; label < categories.length; label++) {
            for (let i = 1; i <= indices[label]; i++) {
                const imgPath = `${imageDir}/${categories[label]}/${categories[label]} ${i}.png`;
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = imgPath;
                await new Promise(resolve => img.onload = resolve);

                const tensor = tf.tidy(() => {
                    return tf.browser.fromPixels(img)
                        .resizeNearestNeighbor([64, 64])
                        .toFloat()
                        .div(255.0);
                });
                images.push(tensor);

                const labelVector = new Array(categories.length).fill(0);
                switch (label) {
                    case 0: labelVector[0] = 1; break;
                    case 1: labelVector[1] = 1; break;
                    case 2: labelVector[2] = 1; labelVector[4] = 1; break;
                    case 3: labelVector[3] = 1; labelVector[4] = 1; labelVector[5] = 1; labelVector[7] = 1; break;
                    case 4: labelVector[4] = 1; break;
                    case 5: labelVector[5] = 1; labelVector[7] = 1; break;
                    case 6: labelVector[6] = 1; labelVector[7] = 1; break;
                    case 7: labelVector[7] = 1; break;
                    case 8: labelVector[4] = 1; labelVector[8] = 1; break;
                    case 9: labelVector[1] = 1; labelVector[9] = 1; break;
                }
                labels.push(tf.tensor1d(labelVector));
            }
        }
        return {
            xs: tf.stack(images),
            ys: tf.stack(labels)
        };
    }

    async function startTraining() {
        await tf.setBackend('webgl').catch(async () => {
            await tf.setBackend('wasm').catch(() => tf.setBackend('cpu'));
        });
        await tf.ready();

        const { xs, ys } = await loadImagesAndLabels();

        const model = tf.sequential();
        model.add(tf.layers.conv2d({ inputShape: [64, 64, 3], filters: 32, kernelSize: 3, activation: 'relu' }));
        model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
        model.add(tf.layers.conv2d({ filters: 64, kernelSize: 3, activation: 'relu' }));
        model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 512, activation: 'relu' }));
        model.add(tf.layers.dense({ units: categories.length, activation: 'sigmoid' }));

        model.compile({
            optimizer: tf.train.adam(1e-4),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });

        await model.fit(xs, ys, {
            epochs: 50,
            batchSize: 4,
            validationSplit: 0.2
        });

        await model.save('downloads://lego-classifier');
        document.getElementById('status').innerText = "Training complete and model saved.";
    }

    startTraining();
    </script>
</body>
</html>
