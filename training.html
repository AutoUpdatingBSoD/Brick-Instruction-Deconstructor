<!DOCTYPE html>
<html>
<head>
    <title>LEGO Multi-Label Classifier - Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
    </style>
</head>
<body>
    <h1>Training LEGO Classifier</h1>
    <button onclick="trainModels()">Train Models</button>
    <pre id="log"></pre>

    <script>
    const pageCategories = ['finish', 'index'];
    const sectionCategories = [
        'bagset', 'dontreadrepeat', 'pageno', 'part',
        'partstep', 'repeat', 'splitdecision', 'subbuild'
    ];
    const imageDir = 'model/dataset';
    const indices = [2, 4, 5, 2, 4, 26, 18, 4, 2, 6];
    //alert(indices[0]);
    async function loadImage(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.src = src;
        });
    }

    async function processImage(img) {
        return tf.tidy(() => {
            return tf.browser.fromPixels(img)
                .resizeNearestNeighbor([64, 64])
                .toFloat()
                .div(255.0)
                .expandDims();
        });
    }

    function buildModel(outputSize) {
        const model = tf.sequential();
        model.add(tf.layers.conv2d({ inputShape: [64, 64, 3], filters: 16, kernelSize: 3, activation: 'relu' }));
        model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
        model.add(tf.layers.dense({ units: outputSize, activation: 'sigmoid' }));
        model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });
        return model;
    }

    function getLabelVector(label, categories) {
            const labelVector = new Array(categories.length).fill(0);
            switch (label) {
            case 0: labelVector[0] = 1; labelVector[4] = 1; break;
            case 1: labelVector[1] = 1; labelVector[4] = 1; labelVector[5] = 1; labelVector[7] = 1; break;
            case 2: labelVector[2] = 1; break;
            case 3: labelVector[3] = 1; break;
            case 4: labelVector[4] = 1; break;
            case 5: labelVector[5] = 1; labelVector[7] = 1; break;
            case 6: labelVector[6] = 1; labelVector[7] = 1; break;
            case 7: labelVector[7] = 1; break;
            case 8: labelVector[4] = 1; labelVector[8] = 1; break;
            case 9: labelVector[1] = 1; labelVector[9] = 1; break;
            }
        return vec;
    }

    async function trainModels() {
        const log = document.getElementById('log');
        log.textContent = 'Loading images...\n';

        const pageXs = [], pageYs = [];
        const sectionXs = [], sectionYs = [];
        console.log(indices[0]);
        for (let i = 0; i < indices.length; i++) {
            const label = i;
                for (let j = 1; j <= indices[i]; j++){
                    
                const category = label < 2 ? 'page' : 'section';
                const path = `${imageDir}/${category}/${category} ${j}.png`;
                const img = await loadImage(path);
                const tensor = await processImage(img);
    
                if (j < 2) {
                    pageXs.push(tensor);
                    pageYs.push(getLabelVector(label, pageCategories));
                }
                else {            
                    sectionXs.push(tensor);
                    sectionYs.push(getLabelVector(label, sectionCategories));
                }
                log.textContent += `Loaded image ${i + 1} as ${label}\n`;
            }
        }

        const pageModel = buildModel(pageCategories.length);
        const sectionModel = buildModel(sectionCategories.length);

        await pageModel.fit(tf.concat(pageXs), tf.tensor2d(pageYs), { epochs: 20 });
        await sectionModel.fit(tf.concat(sectionXs), tf.tensor2d(sectionYs), { epochs: 20 });

        await pageModel.save('downloads://page-model');
        await sectionModel.save('downloads://section-model');

        log.textContent += 'Models trained and saved!';
    }
    </script>
</body>
</html>
